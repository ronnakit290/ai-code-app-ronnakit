import * as vscode from "vscode";
import * as path from "path";

import { getGlobalAI } from "../config/ai.js";
import {
  buildExistingPathsSummary,
  requestPathPlan,
  coerceGeneratedPaths,
} from "./generatePaths.js";

const FALLBACK_MODEL = "gpt-4.1-mini";

/**
 * Extract code content from an AI response.
 * If a fenced code block exists, return its inner content; otherwise return the raw text.
 */
export function extractCodeFromText(text) {
  if (!text) return "";
  const fenceMatch = text.match(/```[a-zA-Z0-9]*\n([\s\S]*?)```/);
  if (fenceMatch) return fenceMatch[1].replace(/\r?\n$/, "");
  return text;
}

/**
 * Ask AI to generate the full file content for a given relative file path.
 */
async function requestFileContent(model, instructions, existingPathsSummary, relativeFilePath) {
  const ext = path.extname(relativeFilePath).replace(/^\./, "");
  const systemPrompt = `คุณเป็นผู้ช่วย AI สำหรับสร้างไฟล์โค้ดแบบครบถ้วน ถูกต้อง และพร้อมใช้งาน

ข้อกำหนด:
- ให้ผลลัพธ์เป็นเนื้อหาไฟล์เดียวเท่านั้นสำหรับ path ที่กำหนด
- ใส่โค้ดเต็มทั้งไฟล์ (ไม่ใช่แค่ snippet)
- ถ้ารู้ภาษาจากนามสกุลไฟล์ (.${ext || "unknown"}) ให้ใช้ภาษานั้น
- ไม่ใส่คำอธิบายอื่น ๆ ที่ไม่ใช่โค้ดในเอาต์พุต
- หากใช้โค้ดบล็อก ให้ห่อด้วย \`\`\` และภาษาให้ตรงกับชนิดไฟล์`;

  const userPrompt = `สร้างไฟล์สำหรับ path: ${relativeFilePath}
ตามข้อกำหนดต่อไปนี้: ${instructions}

โครงสร้างที่มีใน workspace (บางส่วน):
- ไดเรกทอรี: ${existingPathsSummary.directories.slice(0, 20).join(", ")}${
    existingPathsSummary.directories.length > 20 ? "..." : ""
  }

เอาต์พุตเป็นเนื้อหาไฟล์เท่านั้น`;

  try {
    const client = getGlobalAI();
    const response = await client.chat.completions.create({
      model: model,
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      temperature: 0.1,
      max_tokens: 3500,
    });

    const content = response.choices?.[0]?.message?.content || "";
    return extractCodeFromText(content);
  } catch (error) {
    console.warn(`AI content generation failed for ${relativeFilePath}: ${error instanceof Error ? error.message : String(error)}`);
    // Fallback stub content
    const header = `// Auto-generated by AI for ${relativeFilePath}\n// Instruction: ${instructions}\n`;
    return header + "\n";
  }
}

async function ensureParentDir(uri) {
  const parent = vscode.Uri.joinPath(uri, "..");
  await vscode.workspace.fs.createDirectory(parent);
}

async function exists(uri) {
  try {
    await vscode.workspace.fs.stat(uri);
    return true;
  } catch {
    return false;
  }
}

/**
 * Main command: Create Project By AI
 * - Generates a set of file paths via AI (like generatePaths)
 * - Generates file contents for selected files
 * - Writes files to disk (skips existing by default)
 */
export async function createProjectByAI() {
  try {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
      vscode.window.showErrorMessage("No workspace folder is open");
      return;
    }
    const workspaceFolder = workspaceFolders[0];

    const instructions = await vscode.window.showInputBox({
      prompt: "Describe the project/files you want to generate",
      placeHolder: "e.g., Next.js app with auth page, layout, and api route",
    });
    if (instructions === undefined) return;
    if (!instructions.trim()) {
      vscode.window.showWarningMessage("No instructions provided");
      return;
    }

    const config = vscode.workspace.getConfiguration();
    const model = config.get("ai.model") || FALLBACK_MODEL;

    const existingPathsSummary = await buildExistingPathsSummary(
      workspaceFolder,
      100
    );

    let responsePayload;
    await vscode.window.withProgress(
      {
        location: vscode.ProgressLocation.Notification,
        title: "Planning files to generate...",
        cancellable: false,
      },
      async (progress) => {
        progress.report({ increment: 0 });
        responsePayload = await requestPathPlan(
          model,
          instructions.trim(),
          existingPathsSummary
        );
        progress.report({ increment: 100 });
      }
    );

    const generated = coerceGeneratedPaths(responsePayload);
    const fileCandidates = generated.filter((g) => g.pathKind === "file");
    if (fileCandidates.length === 0) {
      vscode.window.showInformationMessage("No file paths proposed by AI.");
      return;
    }

    const quickPickItems = fileCandidates.map((item) => ({
      label: item.path,
      description: "📄 File",
      picked: true,
      path: item.path,
    }));

    const selections = await vscode.window.showQuickPick(quickPickItems, {
      canPickMany: true,
      placeHolder: "Select files to generate",
    });
    if (!selections || selections.length === 0) {
      vscode.window.showInformationMessage("No files selected.");
      return;
    }

    const overwriteChoice = await vscode.window.showQuickPick(
      [
        { label: "Skip existing files", value: "skip" },
        { label: "Overwrite all existing files", value: "overwrite" },
      ],
      { placeHolder: "When a file already exists..." }
    );
    const overwriteAll = overwriteChoice?.value === "overwrite";

    const created = [];
    const skipped = [];
    const overwritten = [];
    const failures = [];

    await vscode.window.withProgress(
      {
        location: vscode.ProgressLocation.Notification,
        title: "Generating files...",
        cancellable: false,
      },
      async (progress) => {
        const total = selections.length;
        let done = 0;

        for (const sel of selections) {
          try {
            const target = vscode.Uri.joinPath(workspaceFolder.uri, sel.path);
            await ensureParentDir(target);

            const fileExists = await exists(target);
            if (fileExists && !overwriteAll) {
              skipped.push(sel.path);
              done += 1;
              progress.report({ increment: Math.floor((done / total) * 100) });
              continue;
            }

            const content = await requestFileContent(
              model,
              instructions.trim(),
              existingPathsSummary,
              sel.path
            );

            const buffer = Buffer.from(content, "utf8");
            await vscode.workspace.fs.writeFile(target, buffer);

            if (fileExists) overwritten.push(sel.path);
            else created.push(sel.path);

            done += 1;
            progress.report({ increment: Math.floor((done / total) * 100) });
          } catch (error) {
            failures.push({ path: sel.path, error: error instanceof Error ? error.message : String(error) });
          }
        }
      }
    );

    const parts = [];
    if (created.length) parts.push(`Created ${created.length}`);
    if (overwritten.length) parts.push(`Overwritten ${overwritten.length}`);
    if (skipped.length) parts.push(`Skipped ${skipped.length}`);
    const summary = parts.length ? parts.join(", ") : "No changes";

    if (failures.length) {
      const details = failures.map((f) => `${f.path}: ${f.error}`).join("\n");
      vscode.window.showErrorMessage(`Create Project By AI: ${summary}. Failed:\n${details}`);
    } else {
      vscode.window.showInformationMessage(`Create Project By AI: ${summary}.`);
    }
  } catch (error) {
    vscode.window.showErrorMessage(`Error: ${error instanceof Error ? error.message : String(error)}`);
  }
}

export default createProjectByAI;
